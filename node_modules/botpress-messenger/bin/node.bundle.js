module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/Users/slvn/Desktop/botpress-messenger";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var checkVersion = __webpack_require__(2);
	
	var path = __webpack_require__(3);
	var fs = __webpack_require__(4);
	var _ = __webpack_require__(5);
	var uuid = __webpack_require__(6);
	var Promise = __webpack_require__(7);
	
	var Messenger = __webpack_require__(8);
	var actions = __webpack_require__(13);
	var outgoing = __webpack_require__(14);
	var incoming = __webpack_require__(15);
	var ngrok = __webpack_require__(18);
	
	var messenger = null;
	var outgoingPending = outgoing.pending;
	
	var outgoingMiddleware = function outgoingMiddleware(event, next) {
	  if (event.platform !== 'facebook') {
	    return next();
	  }
	
	  if (!outgoing[event.type]) {
	    return next('Unsupported event type: ' + event.type);
	  }
	
	  var setValue = function setValue(method) {
	    return function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      if (event.__id && outgoingPending[event.__id]) {
	
	        if (args && args[0] && args[0].message_id) {
	          var ts = args[0].message_id.split(':')[0];
	          ts = ts && ts.substr(4);
	          outgoingPending[event.__id].timestamp = parseInt(ts);
	          outgoingPending[event.__id].mid = args[0].message_id;
	        }
	
	        if (method === 'resolve' && (event.raw.waitDelivery || event.raw.waitRead)) {
	          // We skip setting this value because we wait
	        } else {
	          outgoingPending[event.__id][method].apply(null, args);
	          delete outgoingPending[event.__id];
	        }
	      }
	    };
	  };
	
	  outgoing[event.type](event, next, messenger).then(setValue('resolve'), setValue('reject'));
	};
	
	var initializeMessenger = function initializeMessenger(bp, configurator) {
	  return configurator.loadAll().then(function (config) {
	    messenger = new Messenger(bp, config);
	
	    // regenerate a new ngrok url and update it to facebook
	    if (!config.ngrok || !config.connected) {
	      return Promise.resolve(true);
	    }
	
	    bp.logger.debug('[messenger] updating ngrok to facebook');
	
	    return ngrok.getUrl(bp.botfile.port).then(function (url) {
	      url = url.replace(/https:\/\//i, '');
	      messenger.setConfig({ hostname: url });
	    }).then(function () {
	      return configurator.saveAll(messenger.getConfig());
	    }).then(function () {
	      return messenger.updateSettings();
	    }).then(function () {
	      return messenger.connect();
	    }).then(function () {
	      return bp.notifications.send({
	        level: 'info',
	        message: 'Upgraded messenger app webhook with new ngrok url'
	      });
	    }).catch(function (err) {
	      bp.logger.error('[messenger] error updating ngrok', err);
	      bp.notifications.send({
	        level: 'error',
	        message: 'Error updating app webhook with new ngrok url. Please see logs for details.'
	      });
	    });
	  });
	};
	
	module.exports = {
	
	  config: {
	    applicationID: { type: 'string', required: true, default: '', env: 'MESSENGER_APP_ID' },
	    accessToken: { type: 'string', required: true, default: '', env: 'MESSENGER_ACCESS_TOKEN' },
	    appSecret: { type: 'string', required: true, default: '', env: 'MESSENGER_APP_SECRET' },
	    verifyToken: { type: 'string', required: false, default: uuid.v4() },
	    validated: { type: 'bool', required: false, default: false },
	    connected: { type: 'bool', required: false, default: false },
	    hostname: { type: 'string', required: false, default: '' },
	    homepage: { type: 'string' },
	    ngrok: { type: 'bool', required: false, default: false },
	    displayGetStarted: { type: 'bool', required: false, default: false },
	    greetingMessage: { type: 'string', required: false, default: 'Default greeting message' },
	    persistentMenu: { type: 'bool', required: false, default: false },
	    persistentMenuItems: { type: 'any', required: false, default: [], validation: function validation(v) {
	        return _.isArray(v);
	      } },
	    automaticallyMarkAsRead: { type: 'bool', required: false, default: true },
	    targetAudience: { type: 'string', required: true, default: 'openToAll' },
	    targetAudienceOpenToSome: { type: 'string', required: false },
	    targetAudienceCloseToSome: { type: 'string', required: false },
	    trustedDomains: { type: 'any', required: false, default: [], validation: function validation(v) {
	        return _.isArray(v);
	      } },
	    autoRespondGetStarted: { type: 'bool', required: false, default: true }, // deprecated
	    autoResponse: { type: 'string', required: false, default: 'Hello!' }, // deprecated
	    autoResponseOption: { type: 'string', required: false, default: 'noResponse' },
	    autoResponseText: { type: 'string', required: false, default: 'Hello, human!' },
	    autoResponsePostback: { type: 'string', required: false, default: 'YOUR_POSTBACK' }
	  },
	
	  init: function init(bp) {
	
	    checkVersion(bp, __dirname);
	
	    bp.middlewares.register({
	      name: 'messenger.sendMessages',
	      type: 'outgoing',
	      order: 100,
	      handler: outgoingMiddleware,
	      module: 'botpress-messenger',
	      description: 'Sends out messages that targets platform = messenger.' + ' This middleware should be placed at the end as it swallows events once sent.'
	    });
	
	    bp.messenger = {};
	    _.forIn(actions, function (action, name) {
	      bp.messenger[name] = action;
	      var sendName = name.replace(/^create/, 'send');
	      bp.messenger[sendName] = Promise.method(function () {
	        var msg = action.apply(this, arguments);
	        msg.__id = new Date().toISOString() + Math.random();
	        var resolver = { event: msg };
	
	        var promise = new Promise(function (resolve, reject) {
	          resolver.resolve = resolve;
	          resolver.reject = reject;
	        });
	
	        outgoingPending[msg.__id] = resolver;
	
	        bp.middlewares.sendOutgoing(msg);
	        return promise;
	      });
	    });
	  },
	
	  ready: function ready(bp, config) {
	
	    initializeMessenger(bp, config).then(function () {
	      incoming(bp, messenger);
	
	      messenger.on('raw_webhook_body', function (e) {
	        bp.events.emit('messenger.raw_webhook_body', e);
	      });
	
	      messenger.on('raw_send_request', function (e) {
	        bp.events.emit('messenger.raw_send_body', e);
	      });
	
	      var router = bp.getRouter('botpress-messenger');
	
	      router.get('/config', function (req, res) {
	        res.send(messenger.getConfig());
	      });
	
	      router.post('/config', function (req, res) {
	        messenger.setConfig(req.body);
	        config.saveAll(messenger.getConfig()).then(function () {
	          return messenger.updateSettings();
	        }).then(function () {
	          return res.sendStatus(200);
	        }).catch(function (err) {
	          res.status(500).send({ message: err.message });
	        });
	      });
	
	      router.get('/ngrok', function (req, res) {
	        ngrok.getUrl().then(function (url) {
	          return res.send(url);
	        });
	      });
	
	      router.post('/connection', function (req, res) {
	        if (messenger.getConfig().connected) {
	          messenger.disconnect().then(function () {
	            return res.sendStatus(200);
	          }).catch(function (err) {
	            return res.status(500).send({ message: err.message });
	          });
	        } else {
	          messenger.connect().then(function () {
	            return res.sendStatus(200);
	          }).catch(function (err) {
	            return res.status(500).send({ message: err.message });
	          });
	        }
	      });
	
	      router.post('/validation', function (req, res) {
	        messenger.sendValidationRequest().then(function (json) {
	          res.send(json);
	        }).catch(function (err) {
	          res.status(500).send({ message: err.message });
	        });
	      });
	
	      router.get('/homepage', function (req, res) {
	        var packageJSON = JSON.parse(fs.readFileSync(path.join(__dirname, '../package.json')));
	        res.send({ homepage: packageJSON.homepage });
	      });
	    });
	  }
	};

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = require("botpress-version-manager");

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = require("lodash");

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = require("uuid");

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = require("bluebird");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * Messenger
	 *
	 * This file contains one class Messenger, which in charge of communication between
	 * botpress and fb messenger.
	 *
	 */
	
	var Promise = __webpack_require__(7);
	var EventEmitter = __webpack_require__(9);
	var crypto = __webpack_require__(10);
	var fetch = __webpack_require__(11);
	var _ = __webpack_require__(5);
	var bodyParser = __webpack_require__(12);
	
	fetch.promise = Promise;
	
	var normalizeString = function normalizeString(str) {
	  return str.replace(/[^a-zA-Z0-9]+/g, '').toUpperCase();
	};
	
	var Messenger = function (_EventEmitter) {
	  _inherits(Messenger, _EventEmitter);
	
	  function Messenger(bp, config) {
	    _classCallCheck(this, Messenger);
	
	    var _this = _possibleConstructorReturn(this, (Messenger.__proto__ || Object.getPrototypeOf(Messenger)).call(this));
	
	    if (!bp || !config) {
	      throw new Error('You need to specify botpress and config');
	    }
	
	    _this.setConfig(config);
	
	    _this.app = bp.getRouter('botpress-messenger', {
	      'bodyParser.json': false,
	      'auth': function auth(req) {
	        return !/\/webhook/i.test(req.originalUrl);
	      }
	    });
	
	    _this.app.use(bodyParser.json({
	      verify: _this._verifyRequestSignature.bind(_this)
	    }));
	
	    _this._initWebhook();
	    return _this;
	  }
	
	  _createClass(Messenger, [{
	    key: 'setConfig',
	    value: function setConfig(config) {
	      this.config = Object.assign({}, this.config, config);
	    }
	  }, {
	    key: 'getConfig',
	    value: function getConfig() {
	      return this.config;
	    }
	  }, {
	    key: 'connect',
	    value: function connect() {
	      var _this2 = this;
	
	      return this._setupNewWebhook().then(function () {
	        return _this2._subscribePage();
	      });
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      return this._unsubscribePage();
	    }
	  }, {
	    key: 'sendTextMessage',
	    value: function sendTextMessage(recipientId, text, quickReplies, options) {
	      var message = { text: text };
	      var formattedQuickReplies = this._formatQuickReplies(quickReplies);
	      if (formattedQuickReplies && formattedQuickReplies.length > 0) {
	        message.quick_replies = formattedQuickReplies;
	      }
	      return this.sendMessage(recipientId, message, options);
	    }
	  }, {
	    key: 'sendButtonTemplate',
	    value: function sendButtonTemplate(recipientId, text, buttons, options) {
	      var payload = {
	        template_type: 'button',
	        text: text
	      };
	      var formattedButtons = this._formatButtons(buttons);
	      payload.buttons = formattedButtons;
	      return this.sendTemplate(recipientId, payload, options);
	    }
	  }, {
	    key: 'sendGenericTemplate',
	    value: function sendGenericTemplate(recipientId, elements, options) {
	      var payload = {
	        template_type: 'generic',
	        elements: elements
	      };
	      return this.sendTemplate(recipientId, payload, options);
	    }
	  }, {
	    key: 'sendTemplate',
	    value: function sendTemplate(recipientId, payload, options) {
	      var message = {
	        attachment: {
	          type: 'template',
	          payload: payload
	        }
	      };
	      return this.sendMessage(recipientId, message, options);
	    }
	  }, {
	    key: 'sendAttachment',
	    value: function sendAttachment(recipientId, type, url, quickReplies, options) {
	      var message = {
	        attachment: {
	          type: type,
	          payload: { url: url }
	        }
	      };
	      if (options.isReusable && _.isBoolean(options.isReusable)) {
	        message.attachment.payload.is_reusable = options.isReusable;
	      }
	      if (options.attachmentId) {
	        message.attachment.payload = {
	          attachment_id: options.attachmentId
	        };
	      }
	      var formattedQuickReplies = this._formatQuickReplies(quickReplies);
	      if (formattedQuickReplies && formattedQuickReplies.length > 0) {
	        message.quick_replies = formattedQuickReplies;
	      }
	      return this.sendMessage(recipientId, message, options);
	    }
	  }, {
	    key: 'sendAction',
	    value: function sendAction(recipientId, action) {
	      return this.sendRequest({
	        recipient: {
	          id: recipientId
	        },
	        sender_action: action
	      });
	    }
	  }, {
	    key: 'sendMessage',
	    value: function sendMessage(recipientId, message, options) {
	      var _this3 = this;
	
	      var req = function req() {
	        return _this3.sendRequest({
	          recipient: {
	            id: recipientId
	          },
	          message: message
	        });
	      };
	
	      if (options && options.typing) {
	        var autoTimeout = message && message.text ? 500 + message.text.length * 10 : 1000;
	        var timeout = typeof options.typing === 'number' ? options.typing : autoTimeout;
	        return this.sendTypingIndicator(recipientId, timeout).then(req);
	      }
	
	      return req();
	    }
	  }, {
	    key: 'sendValidationRequest',
	    value: function sendValidationRequest() {
	      var applicationID = this.config.applicationID;
	      var accessToken = this.config.accessToken;
	
	      return fetch('https://graph.facebook.com/v2.7/' + applicationID + '/subscriptions_sample', {
	        method: 'POST',
	        headers: { 'Content-Type': 'application/json' },
	        body: JSON.stringify({
	          object_id: applicationID,
	          object: 'page',
	          field: 'messages',
	          custom_fields: { page_id: applicationID },
	          access_token: accessToken
	        })
	      }).then(this._handleFacebookResponse).then(function (res) {
	        return res.json();
	      });
	    }
	  }, {
	    key: 'sendRequest',
	    value: function sendRequest(body, endpoint, method) {
	      var _this4 = this;
	
	      endpoint = endpoint || 'messages';
	      method = method || 'POST';
	
	      var url = 'https://graph.facebook.com/v2.7/me/' + endpoint;
	      return fetch(url + '?access_token=' + this.config.accessToken, {
	        method: method,
	        headers: { 'Content-Type': 'application/json' },
	        body: JSON.stringify(body)
	      }).then(this._handleFacebookResponse).then(function (res) {
	        return res.json();
	      }).then(function (json) {
	        _this4._handleEvent('raw_send_request', { url: url, token: _this4.config.accessToken, body: body, endpoint: endpoint, method: method, response: json });
	        return json;
	      });
	    }
	  }, {
	    key: 'sendThreadRequest',
	    value: function sendThreadRequest(body, method) {
	      return this.sendRequest(body, 'thread_settings', method);
	    }
	  }, {
	    key: 'sendTypingIndicator',
	    value: function sendTypingIndicator(recipientId, milliseconds) {
	      var _this5 = this;
	
	      var timeout = !milliseconds || isNaN(milliseconds) ? 0 : milliseconds;
	      timeout = Math.min(20000, timeout);
	
	      if (milliseconds === true) {
	        timeout = 1000;
	      }
	
	      var before = timeout > 0 ? Promise.resolve(this.sendAction(recipientId, 'typing_on')) : Promise.resolve(true);
	
	      return before.delay(timeout).then(function () {
	        return _this5.sendAction(recipientId, 'typing_off');
	      });
	    }
	  }, {
	    key: 'getUserProfile',
	    value: function getUserProfile(userId) {
	      var url = 'https://graph.facebook.com/v2.7/' + userId + '?fields=first_name,last_name,profile_pic,locale,timezone,gender&access_token=' + this.config.accessToken;
	      return fetch(url).then(this._handleFacebookResponse).then(function (res) {
	        return res.json();
	      }).catch(function (err) {
	        return console.log('Error getting user profile: ' + err);
	      });
	    }
	  }, {
	    key: 'createTargetAudienceSetting',
	    value: function createTargetAudienceSetting() {
	      var setting = { target_audience: {} };
	
	      switch (this.config.targetAudience) {
	        case 'openToAll':
	          setting.target_audience.audience_type = 'all';
	          break;
	        case 'openToSome':
	          var countriesWhitelist = this.config.targetAudienceOpenToSome.split(/\, ?/g);
	          setting.target_audience.audience_type = 'custom';
	          setting.target_audience.countries = {
	            whitelist: countriesWhitelist
	          };
	          break;
	        case 'closeToSome':
	          setting.target_audience.audience_type = 'custom';
	          var countriesBlacklist = this.config.targetAudienceCloseToSome.split(/\, ?/g);
	          setting.target_audience.countries = {
	            blacklist: countriesBlacklist
	          };
	          break;
	        case 'closeToAll':
	          setting.target_audience.audience_type = 'none';
	          break;
	      }
	
	      return setting;
	    }
	  }, {
	    key: 'setTargetAudience',
	    value: function setTargetAudience() {
	      var url = 'https://graph.facebook.com/v2.7/me/messenger_profile?access_token=' + this.config.accessToken;
	      var setting = this.createTargetAudienceSetting();
	
	      return this.sendRequest(setting, 'messenger_profile', 'POST');
	    }
	  }, {
	    key: 'setWhitelistedDomains',
	    value: function setWhitelistedDomains(domains) {
	      var url = 'https://graph.facebook.com/v2.7/me/thread_settings?fields=whitelisted_domains&access_token=' + this.config.accessToken;
	      return fetch(url).then(this._handleFacebookResponse).then(function (res) {
	        return res.json();
	      }).then(function (json) {
	        if (json && json.data && json.data[0]) {
	          return json.data[0].whitelisted_domains;
	        } else {
	          return [];
	        }
	      }).then(function (oldDomains) {
	        if (!oldDomains || !oldDomains.length) {
	          return;
	        }
	
	        fetch(url, {
	          method: 'POST',
	          headers: { 'Content-Type': 'application/json' },
	          body: JSON.stringify({
	            setting_type: 'domain_whitelisting',
	            whitelisted_domains: oldDomains,
	            domain_action_type: 'remove'
	          })
	        });
	      }).then(this._handleFacebookResponse).then(function () {
	        return fetch(url, {
	          method: 'POST',
	          headers: { 'Content-Type': 'application/json' },
	          body: JSON.stringify({
	            setting_type: 'domain_whitelisting',
	            whitelisted_domains: domains,
	            domain_action_type: 'add'
	          })
	        });
	      }).then(this._handleFacebookResponse);
	    }
	  }, {
	    key: 'setGreetingText',
	    value: function setGreetingText(text) {
	      return this.sendThreadRequest({
	        setting_type: 'greeting',
	        greeting: { text: text }
	      });
	    }
	  }, {
	    key: 'deleteGreetingText',
	    value: function deleteGreetingText() {
	      return this.sendThreadRequest({
	        setting_type: 'greeting'
	      }, 'DELETE');
	    }
	  }, {
	    key: 'setGetStartedButton',
	    value: function setGetStartedButton(action) {
	      var payload = typeof action === 'string' ? action : 'GET_STARTED';
	      if (typeof action === 'function') {
	        this.on('postback:' + payload, action);
	      }
	      return this.sendThreadRequest({
	        setting_type: 'call_to_actions',
	        thread_state: 'new_thread',
	        call_to_actions: [{ payload: payload }]
	      });
	    }
	  }, {
	    key: 'deleteGetStartedButton',
	    value: function deleteGetStartedButton() {
	      return this.sendThreadRequest({
	        setting_type: 'call_to_actions',
	        thread_state: 'new_thread'
	      }, 'DELETE');
	    }
	  }, {
	    key: 'setPersistentMenu',
	    value: function setPersistentMenu(buttons) {
	      var formattedButtons = this._formatButtons(buttons);
	      return this.sendThreadRequest({
	        setting_type: 'call_to_actions',
	        thread_state: 'existing_thread',
	        call_to_actions: formattedButtons
	      });
	    }
	  }, {
	    key: 'deletePersistentMenu',
	    value: function deletePersistentMenu() {
	      return this.sendThreadRequest({
	        setting_type: 'call_to_actions',
	        thread_state: 'existing_thread'
	      }, 'DELETE');
	    }
	  }, {
	    key: 'updateSettings',
	    value: function updateSettings() {
	      var _this6 = this;
	
	      var updateGetStarted = function updateGetStarted() {
	        return _this6.config.displayGetStarted ? _this6.setGetStartedButton() : _this6.deleteGetStartedButton();
	      };
	
	      var updateGreetingText = function updateGreetingText() {
	        return _.isEmpty(_this6.config.greetingMessage) ? _this6.deleteGreetingText() : _this6.setGreetingText(_this6.config.greetingMessage);
	      };
	
	      var items = this._reformatPersistentMenuItems(this.config.persistentMenuItems);
	      var updatePersistentMenu = function updatePersistentMenu() {
	        return _this6.config.persistentMenu ? _this6.setPersistentMenu(items) : _this6.deletePersistentMenu();
	      };
	
	      var updateTargetAudience = function updateTargetAudience() {
	        return _this6.setTargetAudience();
	      };
	
	      var updateTrustedDomains = function updateTrustedDomains() {
	        return _this6.setWhitelistedDomains(_this6.config.trustedDomains);
	      };
	
	      var thrown = false;
	      var contextifyError = function contextifyError(context) {
	        return function (err) {
	          if (thrown) throw err;
	          var message = 'Error setting ' + context + '\n' + err.message;
	          thrown = true;
	          throw new Error(message);
	        };
	      };
	
	      return updateGetStarted().catch(contextifyError('get started')).then(updateGreetingText).catch(contextifyError('greeting text')).then(updatePersistentMenu).catch(contextifyError('persistent menu')).then(updateTargetAudience).catch(contextifyError('target audience')).then(updateTrustedDomains).catch(contextifyError('trusted domains'));
	    }
	  }, {
	    key: 'module',
	    value: function module(factory) {
	      return factory.apply(this, [this]);
	    }
	  }, {
	    key: '_formatButtons',
	    value: function _formatButtons(buttons) {
	      return buttons && buttons.map(function (button) {
	        if (typeof button === 'string') {
	          return {
	            type: 'postback',
	            title: button,
	            payload: 'BUTTON_' + normalizeString(button)
	          };
	        } else if (button && button.title) {
	          return button;
	        }
	        return {};
	      });
	    }
	  }, {
	    key: '_formatQuickReplies',
	    value: function _formatQuickReplies(quickReplies) {
	      return quickReplies && quickReplies.map(function (reply) {
	        if (typeof reply === 'string') {
	          return {
	            content_type: 'text',
	            title: reply,
	            payload: 'QR_' + normalizeString(reply)
	          };
	        } else if (reply && reply.title) {
	          return {
	            content_type: reply.content_type || 'text',
	            title: reply.title,
	            payload: reply.payload || 'QR_' + normalizeString(reply.title),
	            image_url: reply.image_url
	          };
	        }
	        return {};
	      });
	    }
	  }, {
	    key: '_handleEvent',
	    value: function _handleEvent(type, event) {
	      this.emit(type, event);
	    }
	  }, {
	    key: '_handleMessageEvent',
	    value: function _handleMessageEvent(event) {
	      var text = event.message.text;
	      if (!text) {
	        return;
	      }
	
	      this._handleEvent('message', event);
	
	      if (event.message && this.config.automaticallyMarkAsRead) {
	        this.sendAction(event.sender.id, 'mark_seen');
	      }
	    }
	  }, {
	    key: '_handleAttachmentEvent',
	    value: function _handleAttachmentEvent(event) {
	      this._handleEvent('attachment', event);
	
	      if (event.message && this.config.automaticallyMarkAsRead) {
	        this.sendAction(event.sender.id, 'mark_seen');
	      }
	    }
	  }, {
	    key: '_handlePostbackEvent',
	    value: function _handlePostbackEvent(event) {
	      var payload = event.postback.payload;
	      if (payload) {
	        this._handleEvent('postback:' + payload, event);
	      }
	      this._handleEvent('postback', event);
	    }
	  }, {
	    key: '_handleQuickReplyEvent',
	    value: function _handleQuickReplyEvent(event) {
	      var payload = event.message.quick_reply && event.message.quick_reply.payload;
	      if (payload) {
	        this._handleEvent('quick_reply:' + payload, event);
	      }
	      this._handleEvent('quick_reply', event);
	
	      if (event.message && this.config.automaticallyMarkAsRead) {
	        this.sendAction(event.sender.id, 'mark_seen');
	      }
	    }
	  }, {
	    key: '_handleFacebookResponse',
	    value: function _handleFacebookResponse(res) {
	      if (!res) return;
	
	      if (res.status < 400) {
	        return res;
	      }
	
	      var errorMessage = 'An error has been returned by Facebook API.';
	      errorMessage += '\nStatus: ' + res.status + ' (' + res.statusText + ')';
	
	      return Promise.resolve(true).then(function () {
	        return res.json();
	      }).then(function (json) {
	        errorMessage += '\n' + json.error.message;
	      }).finally(function () {
	        throw new Error(errorMessage);
	      });
	    }
	  }, {
	    key: '_initWebhook',
	    value: function _initWebhook() {
	      var _this7 = this;
	
	      this.app.get('/webhook', function (req, res) {
	        if (req.query['hub.mode'] === 'subscribe' && req.query['hub.verify_token'] === _this7.config.verifyToken) {
	
	          res.status(200).send(req.query['hub.challenge']);
	        } else {
	          console.error('Failed validation. Make sure the validation tokens match.');
	          res.sendStatus(403);
	        }
	      });
	
	      this.app.post('/webhook', function (req, res) {
	        var data = req.body;
	        if (data.object !== 'page') {
	          return;
	        }
	
	        _this7._handleEvent('raw_webhook_body', data);
	
	        // Iterate over each entry. There may be multiple if batched.
	        data.entry.forEach(function (entry) {
	          if (entry && !entry.messaging) {
	            return;
	          }
	          // Iterate over each messaging event
	          entry.messaging.forEach(function (event) {
	            if (event.message && event.message.is_echo && !_this7.config.broadcastEchoes) {
	              return;
	            }
	            if (event.message && event.message.text) {
	              if (event.message.quick_reply) {
	                _this7._handleQuickReplyEvent(event);
	              } else {
	                _this7._handleMessageEvent(event);
	              }
	            } else if (event.message && event.message.attachments) {
	              _this7._handleAttachmentEvent(event);
	            } else if (event.postback) {
	              _this7._handlePostbackEvent(event);
	            } else if (event.delivery) {
	              _this7._handleEvent('delivery', event);
	            } else if (event.read) {
	              _this7._handleEvent('read', event);
	            } else if (event.account_linking) {
	              _this7._handleEvent('account_linking', event);
	            } else if (event.optin) {
	              _this7._handleEvent('optin', event);
	            } else if (event.referral) {
	              _this7._handleEvent('referral', event);
	            } else if (event.payment) {
	              _this7._handleEvent('payment', event);
	            } else {
	              console.log('Webhook received unknown event: ', event);
	            }
	          });
	        });
	
	        // Must send back a 200 within 20 seconds or the request will time out.
	        res.sendStatus(200);
	      });
	    }
	  }, {
	    key: '_verifyRequestSignature',
	    value: function _verifyRequestSignature(req, res, buf) {
	      if (!/^\/webhook/i.test(req.path)) {
	        return;
	      }
	
	      var signature = req.headers['x-hub-signature'];
	      if (!signature) {
	        throw new Error('Couldn\'t validate the request signature.');
	      } else {
	        var _signature$split = signature.split('='),
	            _signature$split2 = _slicedToArray(_signature$split, 2),
	            hash = _signature$split2[1];
	
	        var expectedHash = crypto.createHmac('sha1', this.config.appSecret).update(buf).digest('hex');
	
	        if (hash != expectedHash) {
	          throw new Error('Couldn\'t validate the request signature.');
	        }
	      }
	    }
	  }, {
	    key: '_reformatPersistentMenuItems',
	    value: function _reformatPersistentMenuItems() {
	      if (this.config.persistentMenu && this.config.persistentMenuItems) {
	        return this.config.persistentMenuItems.map(function (item) {
	
	          if (item.value && item.type === 'postback') {
	            item.payload = item.value;
	            delete item.value;
	          } else if (item.value && item.type === 'url') {
	            item.url = item.value;
	            item.type = 'web_url';
	            delete item.value;
	          }
	          return item;
	        });
	      }
	    }
	  }, {
	    key: '_setupNewWebhook',
	    value: function _setupNewWebhook() {
	      var _this8 = this;
	
	      var oAuthUrl = 'https://graph.facebook.com/v2.7/oauth/access_token' + '?client_id=' + this.config.applicationID + '&client_secret=' + this.config.appSecret + '&grant_type=client_credentials';
	
	      var url = 'https://graph.facebook.com/v2.7/' + this.config.applicationID + '/subscriptions?access_token=';
	
	      return fetch(oAuthUrl).then(this._handleFacebookResponse).then(function (res) {
	        return res.json();
	      }).then(function (json) {
	        return json.access_token;
	      }).then(function (token) {
	        return fetch(url + token, {
	          method: 'POST',
	          headers: { 'Content-Type': 'application/json' },
	          body: JSON.stringify({
	            object: 'page',
	            callback_url: 'https://' + _this8.config.hostname + '/api/botpress-messenger/webhook',
	            verify_token: _this8.config.verifyToken,
	            fields: ['message_deliveries', 'message_reads', 'messages', 'messaging_optins', 'messaging_postbacks', 'messaging_referrals']
	          })
	        });
	      }).then(this._handleFacebookResponse).then(function (res) {
	        return res.json();
	      });
	    }
	  }, {
	    key: '_subscribePage',
	    value: function _subscribePage() {
	      var url = 'https://graph.facebook.com/v2.6/me/subscribed_apps?access_token=' + this.config.accessToken;
	
	      return fetch(url, { method: 'POST' }).then(this._handleFacebookResponse).then(function (res) {
	        return res.json();
	      }).catch(function (err) {
	        return console.log(err);
	      });
	    }
	  }, {
	    key: '_unsubscribePage',
	    value: function _unsubscribePage() {
	      var url = 'https://graph.facebook.com/v2.6/me/subscribed_apps?access_token=' + this.config.accessToken;
	
	      return fetch(url, { method: 'DELETE' }).then(this._handleFacebookResponse).then(function (res) {
	        return res.json();
	      }).catch(function (err) {
	        return console.log(err);
	      });
	    }
	  }]);
	
	  return Messenger;
	}(EventEmitter);
	
	module.exports = Messenger;

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = require("eventemitter2");

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = require("crypto");

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = require("node-fetch");

/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = require("body-parser");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(5);
	
	var validateUserId = function validateUserId(userId) {
	  if (!/[0-9]+/.test(userId)) {
	    throw new Error('Invalid userId');
	  }
	};
	
	var validateText = function validateText(text) {
	  if (typeof text !== 'string' || text.length > 300) {
	    throw new Error('Text must be a string less than 300 chars.');
	  }
	};
	
	var validateQuickReplies = function validateQuickReplies(quick_replies) {
	  if (!_.isArray(quick_replies)) {
	    throw new Error('quick_replies must be an array');
	  }
	
	  _.forEach(quick_replies, validateQuickReply);
	};
	
	var validateQuickReply = function validateQuickReply(quick_reply) {
	  if (typeof quick_reply !== 'string') {
	    if (!quick_reply || typeof quick_reply.title !== 'string') {
	      throw new Error('Expected quick_reply to be a string or an object' + 'with a title.');
	    }
	  }
	};
	
	var validateTyping = function validateTyping(typing) {
	  if (!_.isBoolean(typing) && !_.isNumber(typing)) {
	    throw new Error('Expected typing to be a boolean of a number');
	  }
	};
	
	var validateAttachmentType = function validateAttachmentType(type) {
	  if (typeof type !== 'string') {
	    throw new Error('Expected attachment type to be a text');
	  }
	
	  if (!_.includes(['image', 'video', 'audio', 'file'], type.toLowerCase())) {
	    throw new Error('Invalid attachment type');
	  }
	};
	
	var validateUrl = function validateUrl(url) {
	  if (typeof url !== 'string') {
	    throw new Error('Expected URL to be a string');
	  }
	};
	
	var validateTemplatePayload = function validateTemplatePayload(payload) {
	  if (!_.isPlainObject(payload)) {
	    throw new Error('Template payload must be a plain object');
	  }
	
	  if (typeof payload.template_type !== 'string') {
	    throw new Error('"template_type" must be set');
	  }
	};
	
	var validatePersistentMenu = function validatePersistentMenu(elements) {
	  if (!_.isArray(elements)) {
	    throw new Error('Expected elements to be an array');
	  }
	
	  _.forEach(elements, function (element) {
	    if (!_.isPlainObject(element)) {
	      throw new Error('Expected element to be a plain object');
	    }
	  });
	};
	
	var createText = function createText(userId, text, options) {
	  validateUserId(userId);
	  validateText(text);
	
	  if (options && options.quick_replies) {
	    validateQuickReplies(options.quick_replies);
	  }
	
	  if (options && options.typing) {
	    validateTyping(options.typing);
	  }
	
	  return {
	    platform: 'facebook',
	    type: 'text',
	    text: text,
	    raw: {
	      to: userId,
	      message: text,
	      typing: options && options.typing,
	      quick_replies: options && options.quick_replies,
	      waitRead: options && options.waitRead,
	      waitDelivery: options && options.waitDelivery
	    }
	  };
	};
	
	var createAttachment = function createAttachment(userId, type, url, options) {
	  validateUserId(userId);
	  validateAttachmentType(type);
	
	  if (_.isNull(url) && !(options && options.attachmentId)) {
	    throw new Error('If URL is null, you must pass an attachment_id on options object');
	  } else if (options && options.attachmentId) {
	    validateText(options.attachmentId);
	  } else {
	    validateUrl(url);
	  }
	
	  if (options && options.quick_replies) {
	    validateQuickReplies(options.quick_replies);
	  }
	
	  if (options && options.typing) {
	    validateTyping(options.typing);
	  }
	
	  return {
	    platform: 'facebook',
	    type: 'attachment',
	    text: 'Attachment (' + type + ') : ' + url,
	    raw: {
	      to: userId,
	      type: type,
	      url: url,
	      isReusable: options && options.isReusable,
	      attachmentId: options && options.attachmentId,
	      typing: options && options.typing,
	      quick_replies: options && options.quick_replies,
	      waitRead: options && options.waitRead,
	      waitDelivery: options && options.waitDelivery
	    }
	  };
	};
	
	var createTemplate = function createTemplate(userId, payload, options) {
	  validateUserId(userId);
	  validateTemplatePayload(payload);
	
	  if (options && options.typing) {
	    validateTyping(options.typing);
	  }
	
	  return {
	    platform: 'facebook',
	    type: 'template',
	    text: 'Template (' + payload.template_type + ')',
	    raw: {
	      to: userId,
	      payload: payload,
	      typing: options && options.typing,
	      waitRead: options && options.waitRead,
	      waitDelivery: options && options.waitDelivery
	    }
	  };
	};
	
	var createTyping = function createTyping(userId, typing) {
	  validateUserId(userId);
	  validateTyping(typing);
	
	  return {
	    platform: 'facebook',
	    type: 'typing',
	    text: 'Typing: ' + typing,
	    raw: {
	      to: userId,
	      typing: typing
	    }
	  };
	};
	
	var createSeen = function createSeen(userId) {
	  validateUserId(userId);
	
	  return {
	    platform: 'facebook',
	    type: 'seen',
	    text: 'Mark as seen',
	    raw: {
	      to: userId
	    }
	  };
	};
	
	var createPersistentMenu = function createPersistentMenu(elements) {
	  if (!elements) {
	    return {
	      platform: 'facebook',
	      type: 'persistent_menu',
	      text: 'Delete the persistent menu',
	      raw: {
	        delete: true
	      }
	    };
	  }
	
	  validatePersistentMenu(elements);
	  return {
	    platform: 'facebook',
	    type: 'persistent_menu',
	    text: 'Set persistent menu: ' + elements.length + ' items',
	    raw: {
	      delete: false,
	      elements: elements
	    }
	  };
	};
	
	var createGreetingText = function createGreetingText(text) {
	  if (text && text.length > 160) {
	    throw new Error('Greeting text must be less than 160 chars');
	  }
	
	  return {
	    platform: 'facebook',
	    type: 'greeting_text',
	    text: 'Set greeting text: ' + text,
	    raw: {
	      text: text
	    }
	  };
	};
	
	var createGetStarted = function createGetStarted(postback) {
	  return {
	    platform: 'facebook',
	    type: 'get_started',
	    text: 'Setting get started button: ' + !!postback,
	    raw: {
	      enabled: !!postback,
	      postback: postback
	    }
	  };
	};
	
	var createWhitelistedDomains = function createWhitelistedDomains(domains) {
	  if (domains && !_.every(domains, _.isString)) {
	    throw new Error('Expected domains to be a list of string');
	  }
	
	  return {
	    platform: 'facebook',
	    type: 'whitelisted_domains',
	    text: 'Setting whitelisted domains',
	    raw: {
	      domains: domains
	    }
	  };
	};
	
	module.exports = {
	  createText: createText,
	  createAttachment: createAttachment,
	  createTemplate: createTemplate,
	  createTyping: createTyping,
	  createSeen: createSeen,
	  createGetStarted: createGetStarted,
	  createPersistentMenu: createPersistentMenu,
	  createGreetingText: createGreetingText,
	  createWhitelistedDomains: createWhitelistedDomains
	};

/***/ },
/* 14 */
/***/ function(module, exports) {

	'use strict';
	
	var handlePromise = function handlePromise(next, promise) {
	  return promise.then(function (res) {
	    next();
	    return res;
	  }).catch(function (err) {
	    next(err);
	    throw err;
	  });
	};
	
	var handleText = function handleText(event, next, messenger) {
	  return handlePromise(next, messenger.sendTextMessage(event.raw.to, event.raw.message, event.raw.quick_replies, event.raw));
	};
	
	var handleAttachment = function handleAttachment(event, next, messenger) {
	  return handlePromise(next, messenger.sendAttachment(event.raw.to, event.raw.type, event.raw.url, event.raw.quick_replies, event.raw));
	};
	
	var handleTemplate = function handleTemplate(event, next, messenger) {
	  return handlePromise(next, messenger.sendTemplate(event.raw.to, event.raw.payload, event.raw));
	};
	
	var handleTyping = function handleTyping(event, next, messenger) {
	  return handlePromise(next, messenger.sendTypingIndicator(event.raw.to, event.raw.typing));
	};
	
	var handleSeen = function handleSeen(event, next, messenger) {
	  return handlePromise(next, messenger.sendAction(event.raw.to, 'mark_seen'));
	};
	
	var handleGetStarted = function handleGetStarted(event, next, messenger) {
	  if (event.raw.enabled) {
	    return handlePromise(next, messenger.setGetStartedButton(event.raw.postback));
	  } else {
	    return handlePromise(next, messenger.deleteGetStartedButton());
	  }
	};
	
	var handlePersistentMenu = function handlePersistentMenu(event, next, messenger) {
	  if (event.raw.delete) {
	    return handlePromise(next, messenger.deletePersistentMenu());
	  } else {
	    return handlePromise(next, messenger.setPersistentMenu(event.raw.elements));
	  }
	};
	
	var handleGreetingText = function handleGreetingText(event, next, messenger) {
	  if (event.raw.text) {
	    return handlePromise(next, messenger.setGreetingText(event.raw.text));
	  } else {
	    return handlePromise(next, messenger.deleteGreetingText(event.raw.text));
	  }
	};
	
	var handleWhitelistedDomains = function handleWhitelistedDomains(event, next, messenger) {
	  return handlePromise(next, messenger.setWhitelistedDomains(event.raw.domains));
	};
	
	module.exports = {
	  'text': handleText,
	  'attachment': handleAttachment,
	  'template': handleTemplate,
	  'typing': handleTyping,
	  'seen': handleSeen,
	  'greeting_text': handleGreetingText,
	  'persistent_menu': handlePersistentMenu,
	  'whitelisted_domains': handleWhitelistedDomains,
	  'get_started': handleGetStarted,
	  pending: {}
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _lruCache = __webpack_require__(16);
	
	var _lruCache2 = _interopRequireDefault(_lruCache);
	
	var _users = __webpack_require__(17);
	
	var _users2 = _interopRequireDefault(_users);
	
	var _outgoing = __webpack_require__(14);
	
	var _outgoing2 = _interopRequireDefault(_outgoing);
	
	var _lodash = __webpack_require__(5);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = function (bp, messenger) {
	
	  var users = (0, _users2.default)(bp, messenger);
	
	  var messagesCache = (0, _lruCache2.default)({
	    max: 10000,
	    maxAge: 60 * 60 * 1000
	  });
	
	  var preprocessEvent = function preprocessEvent(payload) {
	    var userId = payload.sender.id;
	    var mid = payload.message && payload.message.mid;
	
	    if (mid && !messagesCache.has(mid)) {
	      // We already processed this message
	      payload.alreadyProcessed = true;
	    } else {
	      // Mark it as processed
	      messagesCache.set(mid, true);
	    }
	
	    return users.getOrFetchUserProfile(userId);
	  };
	
	  messenger.on('message', function (e) {
	    preprocessEvent(e).then(function (profile) {
	      // push the message to the incoming middleware
	      bp.middlewares.sendIncoming({
	        platform: 'facebook',
	        type: 'message',
	        user: profile,
	        text: e.message.text,
	        raw: e
	      });
	    });
	  });
	
	  messenger.on('attachment', function (e) {
	    preprocessEvent(e).then(function (profile) {
	      bp.middlewares.sendIncoming({
	        platform: 'facebook',
	        type: 'attachments',
	        user: profile,
	        text: e.message.attachments.length + ' attachments',
	        raw: e
	      });
	      e.message.attachments.forEach(function (att) {
	        bp.middlewares.sendIncoming({
	          platform: 'facebook',
	          type: att.type,
	          user: profile,
	          text: att.payload.url ? att.payload.url : JSON.stringify(att.payload),
	          raw: att
	        });
	      });
	    });
	  });
	
	  messenger.on('postback', function (e) {
	    preprocessEvent(e).then(function (profile) {
	      bp.middlewares.sendIncoming({
	        platform: 'facebook',
	        type: 'postback',
	        user: profile,
	        text: e.postback.payload,
	        raw: e
	      });
	
	      if (e.postback.payload === 'GET_STARTED') {
	        var mConfig = messenger.getConfig();
	
	        if (mConfig.displayGetStarted && mConfig.autoResponseOption == 'autoResponseText') {
	          bp.messenger.sendText(profile.id, mConfig.autoResponseText);
	        }
	
	        if (mConfig.displayGetStarted && mConfig.autoResponseOption == 'autoResponsePostback') {
	          bp.middlewares.sendIncoming({
	            platform: 'facebook',
	            type: 'postback',
	            user: profile,
	            text: mConfig.autoResponsePostback,
	            raw: e
	          });
	        }
	      }
	    });
	  });
	
	  messenger.on('quick_reply', function (e) {
	    preprocessEvent(e).then(function (profile) {
	      bp.middlewares.sendIncoming({
	        platform: 'facebook',
	        type: 'quick_reply',
	        user: profile,
	        text: e.message.quick_reply.payload,
	        raw: e
	      });
	    });
	  });
	
	  messenger.on('delivery', function (e) {
	
	    _lodash2.default.values(_outgoing2.default.pending).forEach(function (pending) {
	      var recipient = pending.event.raw.to;
	      if (e.sender.id === recipient && pending.event.raw.waitDelivery) {
	        if (_lodash2.default.includes(e.delivery.mids, pending.mid)) {
	          pending.resolve(e);
	          delete _outgoing2.default.pending[pending.event.__id];
	        }
	      }
	    });
	
	    preprocessEvent(e).then(function (profile) {
	      bp.middlewares.sendIncoming({
	        platform: 'facebook',
	        type: 'delivery',
	        user: profile,
	        text: e.delivery.watermark.toString(),
	        raw: e
	      });
	    });
	  });
	
	  messenger.on('read', function (e) {
	
	    _lodash2.default.values(_outgoing2.default.pending).forEach(function (pending) {
	      var recipient = pending.event.raw.to;
	      if (e.sender.id === recipient) {
	        if (pending.event.raw.waitRead && pending.timestamp && pending.timestamp <= e.read.watermark) {
	          pending.resolve(e);
	          delete _outgoing2.default.pending[pending.event.__id];
	        }
	      }
	    });
	
	    preprocessEvent(e).then(function (profile) {
	      bp.middlewares.sendIncoming({
	        platform: 'facebook',
	        type: 'read',
	        user: profile,
	        text: e.read.watermark.toString(),
	        raw: e
	      });
	    });
	  });
	
	  messenger.on('account_linking', function () {
	    bp.logger.warn('[messenger] ACCOUNT_LINKING NOT IMPLEMENTED, Your pull requests are welcome :)');
	  });
	
	  messenger.on('optin', function (e) {
	    preprocessEvent(e).then(function (profile) {
	      bp.middlewares.sendIncoming({
	        platform: 'facebook',
	        type: 'optin',
	        user: profile,
	        text: e.optin.ref,
	        raw: e
	      });
	    });
	  });
	
	  messenger.on('referral', function (e) {
	    preprocessEvent(e).then(function (profile) {
	      bp.middlewares.sendIncoming({
	        platform: 'facebook',
	        type: 'referral',
	        user: profile,
	        text: e.referral.ref,
	        raw: e
	      });
	    });
	  });
	
	  messenger.on('payment', function (e) {
	    preprocessEvent(e).then(function (profile) {
	      bp.middlewares.sendIncoming({
	        platform: 'facebook',
	        type: 'payment',
	        text: 'payment',
	        user: profile,
	        payment: e.payment,
	        raw: e
	      });
	    });
	  });
	};

/***/ },
/* 16 */
/***/ function(module, exports) {

	module.exports = require("lru-cache");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 *
	 * User info helper.
	 *
	 * This helper provides following methods:
	 *
	 *   - getOrFetchUserProfile: given `userId` return a promise of user data (with cache)
	 *
	 * Data users' profiles will be cached in `${bp.dataLocation}/botpress-messenger.profiles.json`
	 *
	 */
	
	var Promise = __webpack_require__(7);
	var path = __webpack_require__(3);
	var fs = __webpack_require__(4);
	
	module.exports = function (bp, messenger) {
	
	  var filename = path.join(bp.dataLocation, 'botpress-messenger.profiles.json');
	
	  var loadUserProfiles = function loadUserProfiles() {
	    if (fs.existsSync(filename)) {
	      return JSON.parse(fs.readFileSync(filename));
	    }
	    return {};
	  };
	
	  var saveUserProfiles = function saveUserProfiles(profiles) {
	    var content = JSON.stringify(profiles);
	    fs.writeFileSync(filename, content);
	    bp.logger.debug('messenger: saved user profiles to disk');
	  };
	
	  var userProfiles = loadUserProfiles();
	  var cacheTs = new Date();
	
	  return {
	    getOrFetchUserProfile: Promise.method(function (userId) {
	      if (userProfiles[userId]) {
	        return userProfiles[userId];
	      }
	
	      return messenger.getUserProfile(userId).then(function (profile) {
	        profile.id = userId;
	        userProfiles[userId] = profile;
	        if (new Date() - cacheTs >= 10000) {
	          saveUserProfiles(userProfiles);
	          cacheTs = new Date();
	        }
	
	        return bp.db.saveUser({
	          id: profile.id,
	          platform: 'facebook',
	          gender: profile.gender,
	          timezone: profile.timezone,
	          locale: profile.locale,
	          picture_url: profile.profile_pic,
	          first_name: profile.first_name,
	          last_name: profile.last_name
	        }).return(profile);
	      });
	    })
	  };
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Promise = __webpack_require__(7);
	var ngrok = __webpack_require__(19);
	var url = null;
	
	module.exports = {
	  getUrl: function getUrl(port) {
	    if (url) {
	      return Promise.resolve(url);
	    }
	
	    return Promise.fromCallback(function (callback) {
	      ngrok.connect(port || 3000, callback);
	    }).then(function (u) {
	      return url = u;
	    });
	  },
	  stop: function stop() {
	    if (url) {
	      ngrok.disconnect(url);
	      url = null;
	    }
	  }
	};

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = require("ngrok");

/***/ }
/******/ ]);
//# sourceMappingURL=node.bundle.js.map